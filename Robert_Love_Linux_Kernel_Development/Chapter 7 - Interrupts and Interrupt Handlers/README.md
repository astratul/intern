# Interrupts and Interrupt Handlers

## Interrupts

Interrupts enable hardware to signal to the processor.The processor receives the interrupt and signals the operating system to enable the operating system to respond to the new data. Hardware devices generate interrupts asynchronously with respect to the processor clock—they can occur at any time. Consequently, the kernel can be interrupted at any time to process interrupts. An interrupt is physically produced by electronic signals originating from hardware devices and directed into input pins on an interrupt controller, a simple chip that multi-plexes multiple interrupt lines into a single line to the processor. Upon receiving an interrupt, the interrupt controller sends a signal to the processor.The processor detects this signal and interrupts its current execution to handle the interrupt.The processor can then notify the operating system that an interrupt has occurred, and the operating system can handle the interrupt appropriately.
Different devices can be associated with different interrupts by means of a unique value associated with each interrupt.This way, interrupts from the keyboard are distinct from interrupts from the hard drive.This enables the operating system to differentiate between interrupts and to know which hardware device caused which interrupt. In turn, the operating system can service each interrupt with its corresponding handler. These interrupt values are often called interrupt request (IRQ) lines. Each IRQ line is assigned a numeric value.

## Interrupt Handlers

The function the kernel runs in response to a specific interrupt is called an interrupt handler or interrupt service routine (ISR). Each device that generates interrupts has an associated interrupt handler.
In Linux, interrupt handlers are normal C functions.They match a specific prototype, which enables the kernel to pass the handler information in a standard way, but otherwise they are ordinary functions.What differentiates interrupt handlers from other kernel functions is that the kernel invokes them in response to interrupts and that they run in a special context  called interrupt context.This special context is occasionally called atomic context because, as we shall see, code executing in this context is unable to block.

## Top Halves Versus Bottom Halves
two goals: that an interrupt handler execute quickly and perform a large amount of work.
Because of these competing goals, the processing of interrupts is split into two parts, or halves.The interrupt handler is the top half. The top half is run immediately upon receipt of the interrupt and performs only the work that is time-critical, such as acknowledging receipt of the interrupt or resetting the hardware.Work that can be performed later is deferred until the bottom half.The bottom half runs in the future, at a more convenient time, with all interrupts enabled.

## Registering an Interrupt Handler
Interrupt handlers are the responsibility of the driver managing the hardware. Each device has one associated driver and, if that device uses interrupts (and most do), then that driver must register one interrupt handler. Drivers can register an interrupt handler and enable a given interrupt line for handling with the function request_irq() , which is declared in <linux/interrupt.h> :
```
/* request_irq: allocate a given interrupt line */
int request_irq(unsigned int irq, // specifies the interrupt number to allocate
    irq_handler_t handler, // a function pointer to the actual interrupt handler that services this interrupt
    unsigned long flags, // can be either zero or a bit mask of one or more of the flags defined in <linux/interrupt.h>
    const char *name, // an ASCII text representation of the device associated with the interrupt
    void *dev) // is used for shared interrupt lines
```
Register a given interrupt handler on a given interrupt line.
### Interrupt Handler Flags


* IRQF_DISABLED - when is set, instructs the kernel to disable all interrupts when executing this interrupt handler. When is unset, interrupt handlers run with all interrupts except their own enabled.

* IRQF_SAMPLE_RANDOM - specifies that interrupts generated by this device should contribute to the kernel entropy pool.

* IRQF_TIMER - pecifies that this handler processes interrupts for the system timer.

* IRQF_SHARED - specifies that the interrupt line can be shared among multiple interrupt handlers. Each handler registered on a given line must specify this flag; otherwise, only one handler can exist per line.

### An Interrupt Example

### Freeing an Interrupt Handler
```
void free_irq(unsigned int irq, void *dev)
```
Unregister a given interrupt handler; if no handlers remain on the line, the given interrupt line is disabled.
## Writing an Interrupt Handler
The following is a declaration of an interrupt handler:
```
static irqreturn_t intr_handler(int irq, void *dev)
```
The role of the interrupt handler depends entirely on the device and its reasons for issuing the interrupt.At a minimum, most interrupt handlers need to provide acknowledgment to the device that they received the interrupt. Devices that are more complex need to additionally send and receive data and perform extended work in the interrupt handler.As mentioned, the extended work is pushed as much as possible into the bottom half handler, which is discussed in the next chapter.

### Shared Handlers
A shared handler is registered and executed much like a nonshared handler. Following are three main differences:
* The IRQF_SHARED flag must be set in the flags argument to request_irq() .
* The dev argument must be unique to each registered handler. A pointer to any per-device structure is sufficient; a common choice is the device structure as it is both unique and potentially useful to the handler.You cannot pass NULL for a shared handler!
* The interrupt handler must be capable of distinguishing whether its device actually generated an interrupt.This requires both hardware support and associated logic in the interrupt handler. If the hardware did not offer this capability, there would be no way for the interrupt handler to know whether its associated device or some other device sharing the line caused the interrupt.

### A Real-Life Interrupt Handler
Any alarm or periodic timer functionality is normally implemented via interrupt.The interrupt is equivalent to a real-world clock alarm:The receipt of the interrupt is analogous to a buzzing alarm.
When the RTC driver loads, the function rtc_init() is invoked to initialize the driver. One of its duties is to register the interrupt handler:
```
/* register rtc_interrupt on rtc_irq */
if (request_irq(rtc_irq, rtc_interrupt, IRQF_SHARED, "rtc", (void *)&rtc_port)) {
    printk(KERN_ERR "rtc: cannot register IRQ %d\n", rtc_irq);
    return -EIO;
}
```
## Interrupt Context
When executing an interrupt handler, the kernel is in interrupt context. Recall that process context is the mode of operation the kernel is in while it is executing on behalf of a process—for example, executing a system call or running a kernel thread. In process context, the current macro points to the associated task. Furthermore, because a process is coupled to the kernel in process context, process context can sleep or otherwise invoke the scheduler.
Interrupt context, on the other hand, is not associated with a process.The current macro is not relevant (although it points to the interrupted process).
If a function sleeps, you cannot use it from your interrupt handler—this limits the functions that one can call from an interrupt handler.
Interrupt context is time-critical because the interrupt handler interrupts other code.
Code should be quick and simple. Busy looping is possible, but discouraged.This is an important point; always keep in mind that your interrupt handler has interrupted other code (possibly even another interrupt handler on a different line!). Because of this asynchronous nature, it is imperative that all interrupt handlers be as quick and as simple as possible.As much as possible, work should be pushed out from the interrupt handler and performed in a bottom half, which runs at a more convenient time.

## Implementing Interrupt Handlers
A device issues an interrupt by sending an electric signal over its bus to the interrupt controller. If the interrupt line is enabled (they can be masked out), the interrupt controller sends the interrupt to the processor. In most architectures, this is accomplished by an electrical signal sent over a special pin to the processor. Unless interrupts are disabled in the processor (which can also happen), the processor immediately stops what it is doing, disables the interrupt system, and jumps to a predefined location in memory and executes the code located there.This predefined point is set up by the kernel and is the entry point for interrupt handlers.
The interrupt’s journey in the kernel begins at this predefined entry point, just as system calls enter the kernel through a predefined exception handler. For each interrupt line, the processor jumps to a unique location in memory and executes the code located there. In this manner, the kernel knows the IRQ number of the incoming interrupt. The initial entry point simply saves this value and stores the current register values (which belong to the interrupted task) on the stack; then the kernel calls do_IRQ() . From here onward, most of the interrupt handling code is written in C; however, it is still architecture-dependent.
The do_IRQ() function is declared as
```
unsigned int do_IRQ(struct pt_regs regs)
```


### /proc/interrupts
Procfs is a virtual filesystem that exists only in kernel memory and is typically mounted at /proc . Reading or writing files in procfs invokes kernel functions that simulate reading or writing from a real file.A relevant example is the /proc/interrupts file, which is populated with statistics related to interrupts on the system. 
procfs code is located primarily in fs/proc .The function that provides /proc/interrupts is, not surprisingly, architecture-dependent and named show_interrupts() .

## Interrupt Control
The Linux kernel implements a family of interfaces for manipulating the state of interrupts on a machine.These interfaces enable you to disable the interrupt system for the current processor or mask out an interrupt line for the entire machine.These routines are all architecture-dependent and can be found in < asm/system.h> and <asm/irq.h> .

### Disabling and Enabling Interrupts
To disable interrupts locally for the current processor (and only the current processor) and then later reenable them, do the following: 
```
local_irq_disable();
/* interrupts are disabled .. */
local_irq_enable();
```
These functions are usually implemented as a single assembly operation.

### Disabling a Specific Interrupt Line
In some cases, it is useful to disable only a specific interrupt line for the entire system.This is called masking out an interrupt line.As an example, you might want to disable delivery of a device’s interrupts before manipulating its state. Linux provides four interfaces for this task:
```
void disable_irq(unsigned int irq);
void disable_irq_nosync(unsigned int irq);
void enable_irq(unsigned int irq);
void synchronize_irq(unsigned int irq);
```
### Status of the Interrupt System
It is often useful to know the state of the interrupt system (for example, whether interrupts are enabled or disabled) or whether you are currently executing in interrupt context.
The macro irqs_disabled() , defined in <asm/system.h> , returns nonzero if the interrupt system on the local processor is disabled. Otherwise, it returns zero.
Two macros, defined in <linux/hardirq.h> , provide an interface to check the kernel’s current context.They are
```
in_interrupt()
in_irq()
```
Function Description
* local_irq_disable() Disables local interrupt delivery
* local_irq_enable() Enables local interrupt delivery
* local_irq_save() Saves the current state of local interrupt delivery and then disables it
* local_irq_restore() Restores local interrupt delivery to the given state
* disable_irq() Disables the given interrupt line and ensures no handler on the line is executing before returning 
* disable_irq_nosync() Disables the given interrupt line
* enable_irq() Enables the given interrupt line
* irqs_disabled() Returns nonzero if local interrupt delivery is disabled; otherwise returns zero
* in_interrupt() Returns nonzero if in interrupt context and zero if in process context
* in_irq() Returns nonzero if currently executing an interrupt handler and zero otherwise